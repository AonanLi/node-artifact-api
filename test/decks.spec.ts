import { expect } from 'chai';
import { decodeDeck, encodeDeck, ArtifactDeck } from '../src/index';

describe('Artifact Deck Api', () => {
    describe('decodeDeck function', () => {
        it('Should return the expected deck for the Green/Black Example Code', () => {
            const exampleDeck = {
                heroes:
                    [{ id: 4005, turn: 2 },
                    { id: 10014, turn: 1 },
                    { id: 10017, turn: 3 },
                    { id: 10026, turn: 1 },
                    { id: 10047, turn: 1 }],
                cards:
                    [{ id: 3000, count: 2 },
                    { id: 3001, count: 1 },
                    { id: 10091, count: 3 },
                    { id: 10102, count: 3 },
                    { id: 10128, count: 3 },
                    { id: 10165, count: 3 },
                    { id: 10168, count: 3 },
                    { id: 10169, count: 3 },
                    { id: 10185, count: 3 },
                    { id: 10223, count: 1 },
                    { id: 10234, count: 3 },
                    { id: 10260, count: 1 },
                    { id: 10263, count: 1 },
                    { id: 10322, count: 3 },
                    { id: 10354, count: 3 }],
                name: 'Green/Black Example'
            };
            const testDeck = decodeDeck('ADCJWkTZX05uwGDCRV4XQGy3QGLmqUBg4GQJgGLGgO7AaABR3JlZW4vQmxhY2sgRXhhbXBsZQ__');

            expect(JSON.stringify(testDeck)).to.eq(JSON.stringify(exampleDeck));
        });

        it('Should return an empty deck with name "Invalid Code" when an invalid code is given', () => {
            const invalidDeckCode = 'NOT_A_DECK_CODE';
            const parsedDeck = decodeDeck(invalidDeckCode);

            expect(parsedDeck.name).to.eq('Invalid Code');
        });

        it('Should return the same deck for a deck code generated by the decoder', () => {
            const sourceDeck: ArtifactDeck = {
                heroes:
                    [{ id: 10020, turn: 1 },
                    { id: 10030, turn: 1 },
                    { id: 10047, turn: 1 },
                    { id: 10050, turn: 3 },
                    { id: 10069, turn: 2 }],
                cards:
                    [{ id: 3000, count: 2 },
                    { id: 10104, count: 3 },
                    { id: 10131, count: 3 },
                    { id: 10132, count: 1 },
                    { id: 10184, count: 1 },
                    { id: 10203, count: 2 },
                    { id: 10205, count: 1 },
                    { id: 10206, count: 2 },
                    { id: 10210, count: 1 },
                    { id: 10211, count: 1 },
                    { id: 10214, count: 2 },
                    { id: 10253, count: 2 },
                    { id: 10273, count: 3 },
                    { id: 10297, count: 1 },
                    { id: 10306, count: 2 },
                    { id: 10326, count: 3 },
                    { id: 10328, count: 3 },
                    { id: 10366, count: 1 },
                    { id: 10370, count: 2 },
                    { id: 10410, count: 3 },
                    { id: 10425, count: 1 }],
                name: 'RB Womp'
            };
            const encodedDeckString = encodeDeck(sourceDeck);
            const parsedDeck = decodeDeck(encodedDeckString);

            expect(JSON.stringify(parsedDeck)).to.eq(JSON.stringify(sourceDeck));
        })
    });

    describe('encodeDeck function', () => {
        it('should return deck code for Green/Black Example deck', () => {
            const exampleDeck = {
                heroes:
                    [{ id: 4005, turn: 2 },
                    { id: 10014, turn: 1 },
                    { id: 10017, turn: 3 },
                    { id: 10026, turn: 1 },
                    { id: 10047, turn: 1 }],
                cards:
                    [{ id: 3000, count: 2 },
                    { id: 3001, count: 1 },
                    { id: 10091, count: 3 },
                    { id: 10102, count: 3 },
                    { id: 10128, count: 3 },
                    { id: 10165, count: 3 },
                    { id: 10168, count: 3 },
                    { id: 10169, count: 3 },
                    { id: 10185, count: 3 },
                    { id: 10223, count: 1 },
                    { id: 10234, count: 3 },
                    { id: 10260, count: 1 },
                    { id: 10263, count: 1 },
                    { id: 10322, count: 3 },
                    { id: 10354, count: 3 }],
                name: 'Green/Black Example'
            };

            expect(encodeDeck(exampleDeck)).to.be.a('string').that.equals('ADCJWkTZX05uwGDCRV4XQGy3QGLmqUBg4GQJgGLGgO7AaABR3JlZW4vQmxhY2sgRXhhbXBsZQ__');
        });

        it('should return deck code for Blue/Red Example deck', () => {
            const exampleDeck = {
                heroes:
                    [{ id: 4003, turn: 1 },
                    { id: 10006, turn: 1 },
                    { id: 10030, turn: 1 },
                    { id: 10033, turn: 3 },
                    { id: 10065, turn: 2 }],
                cards:
                    [{ id: 3000, count: 2 },
                    { id: 3001, count: 2 },
                    { id: 10132, count: 3 },
                    { id: 10157, count: 3 },
                    { id: 10191, count: 2 },
                    { id: 10203, count: 2 },
                    { id: 10212, count: 2 },
                    { id: 10223, count: 1 },
                    { id: 10307, count: 3 },
                    { id: 10344, count: 3 },
                    { id: 10366, count: 3 },
                    { id: 10402, count: 3 },
                    { id: 10411, count: 3 },
                    { id: 10418, count: 3 },
                    { id: 10425, count: 3 }],
                name: 'Blue/Red Example'
            };
            expect(encodeDeck(exampleDeck)).to.be.a('string').that.equals('ADCJQUQI30zuwEYg2ABeF1Bu94BmWIBTEkLtAKlAZakAYmHh0JsdWUvUmVkIEV4YW1wbGU_');
        });

        it('Should return "Invalid deck object" if an invalid deck is provided', () => {
            const invalidDeck: any = { foo: 'bar' };
            const encodedDeckString = encodeDeck((invalidDeck as ArtifactDeck));

            expect(encodedDeckString).to.eq('Invalid deck object');
        });

        it('Should return the same code for a deck parsed by the decoder', () => {
            const sourceDeckCode = 'ADCJWkHJLkCChGDU3hdoN4BmwE0AVMCQQQBQ2cBlBhJlIImAUSoAQ9SQiBXb21w';
            const parsedDeck = decodeDeck(sourceDeckCode);
            const encodedDeckString = encodeDeck(parsedDeck);

            expect(encodedDeckString).to.eq(sourceDeckCode);
        });
    });
});
